"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[256],{462:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=t(4848),o=t(8453);const i={},s="Chapter 4: Practical Applications of Motion Planning and Navigation",r={id:"textbook/chapter4/practical",title:"Chapter 4: Practical Applications of Motion Planning and Navigation",description:"Implementing Grid-Based Path Planning",source:"@site/docs/textbook/chapter4/practical.md",sourceDirName:"textbook/chapter4",slug:"/textbook/chapter4/practical",permalink:"/Ai-book/docs/textbook/chapter4/practical",draft:!1,unlisted:!1,editUrl:"https://github.com/AftabAhmed4/Ai-book/edit/main/docs/textbook/chapter4/practical.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"theory",permalink:"/Ai-book/docs/textbook/chapter4/theory"},next:{title:"Chapter 4: Exercises and Problems",permalink:"/Ai-book/docs/textbook/chapter4/exercises"}},l={},p=[{value:"Implementing Grid-Based Path Planning",id:"implementing-grid-based-path-planning",level:2},{value:"A* Path Planning Implementation",id:"a-path-planning-implementation",level:3},{value:"Implementing Sampling-Based Planners",id:"implementing-sampling-based-planners",level:2},{value:"RRT (Rapidly-Exploring Random Tree) Implementation",id:"rrt-rapidly-exploring-random-tree-implementation",level:3},{value:"Navigation in Dynamic Environments",id:"navigation-in-dynamic-environments",level:2},{value:"Dynamic Window Approach (DWA) Implementation",id:"dynamic-window-approach-dwa-implementation",level:3},{value:"Implementing Path Optimization",id:"implementing-path-optimization",level:2},{value:"Path Smoothing with B-Splines",id:"path-smoothing-with-b-splines",level:3},{value:"Implementing Footstep Planning for Bipedal Navigation",id:"implementing-footstep-planning-for-bipedal-navigation",level:2},{value:"Integration: Complete Navigation System",id:"integration-complete-navigation-system",level:2},{value:"Navigation Stack Implementation",id:"navigation-stack-implementation",level:3},{value:"Real-time Navigation Considerations",id:"real-time-navigation-considerations",level:2},{value:"Performance Optimization Techniques",id:"performance-optimization-techniques",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"chapter-4-practical-applications-of-motion-planning-and-navigation",children:"Chapter 4: Practical Applications of Motion Planning and Navigation"}),"\n",(0,a.jsx)(e.h2,{id:"implementing-grid-based-path-planning",children:"Implementing Grid-Based Path Planning"}),"\n",(0,a.jsx)(e.p,{children:"In this section, we'll implement practical algorithms for path planning, starting with grid-based methods."}),"\n",(0,a.jsx)(e.h3,{id:"a-path-planning-implementation",children:"A* Path Planning Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport heapq\nfrom typing import List, Tuple\n\nclass AStarPlanner:\n    def __init__(self, grid_map: np.ndarray):\n        self.grid = grid_map  # 0 = free, 1 = obstacle\n        self.height, self.width = grid_map.shape\n        self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1),  # 4-connected\n                          (-1, -1), (-1, 1), (1, -1), (1, 1)]  # Diagonals\n        self.costs = [1.0, 1.0, 1.0, 1.0, 1.414, 1.414, 1.414, 1.414]  # Movement costs\n    \n    def heuristic(self, pos: Tuple[int, int], goal: Tuple[int, int]) -> float:\n        """Calculate heuristic distance (Euclidean distance)"""\n        return np.sqrt((pos[0] - goal[0])**2 + (pos[1] - goal[1])**2)\n    \n    def is_valid(self, pos: Tuple[int, int]) -> bool:\n        """Check if position is valid (within bounds and not an obstacle)"""\n        x, y = pos\n        return (0 <= x < self.height and \n                0 <= y < self.width and \n                self.grid[x, y] == 0)\n    \n    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """Find optimal path from start to goal using A* algorithm"""\n        # Priority queue: (f_score, g_score, position)\n        open_set = [(0, 0, start)]\n        heapq.heapify(open_set)\n        \n        # Track costs and parents\n        g_score = {start: 0}\n        came_from = {}\n        \n        # Closed set of visited nodes\n        closed_set = set()\n        \n        while open_set:\n            # Get node with lowest f_score\n            f_score, current_g, current = heapq.heappop(open_set)\n            \n            if current == goal:\n                # Reconstruct path\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n            \n            if current in closed_set:\n                continue\n            \n            closed_set.add(current)\n            \n            # Check all neighbors\n            for i, direction in enumerate(self.directions):\n                neighbor = (current[0] + direction[0], current[1] + direction[1])\n                \n                if not self.is_valid(neighbor) or neighbor in closed_set:\n                    continue\n                \n                # Calculate tentative g_score\n                tentative_g = current_g + self.costs[i]\n                \n                if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                    # This path to neighbor is better\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g\n                    f_score = tentative_g + self.heuristic(neighbor, goal)\n                    \n                    heapq.heappush(open_set, (f_score, tentative_g, neighbor))\n        \n        return []  # No path found\n\n# Example usage\ngrid = np.zeros((10, 10))\ngrid[3, 3:7] = 1  # Add an obstacle\nplanner = AStarPlanner(grid)\npath = planner.plan_path((1, 1), (8, 8))\nprint(f"Found path with {len(path)} steps")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"implementing-sampling-based-planners",children:"Implementing Sampling-Based Planners"}),"\n",(0,a.jsx)(e.h3,{id:"rrt-rapidly-exploring-random-tree-implementation",children:"RRT (Rapidly-Exploring Random Tree) Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\nimport random\n\nclass RRTNode:\n    def __init__(self, point: np.ndarray):\n        self.point = point  # Configuration vector\n        self.parent = None\n        self.children = []\n\nclass RRTPlanner:\n    def __init__(self, start: np.ndarray, goal: np.ndarray, bounds: List[Tuple[float, float]], \n                 max_iterations: int = 10000, step_size: float = 0.1):\n        self.start = np.array(start)\n        self.goal = np.array(goal)\n        self.bounds = bounds  # [(min1, max1), (min2, max2), ...]\n        self.max_iterations = max_iterations\n        self.step_size = step_size\n        \n        # Initialize tree with start node\n        self.root = RRTNode(self.start)\n        self.nodes = [self.root]\n        \n        # Collision checking (simplified - would use actual collision detection in practice)\n        self.obstacles = []  # List of obstacles to check against\n    \n    def add_obstacle(self, center: np.ndarray, radius: float):\n        """Add a circular/spherical obstacle"""\n        self.obstacles.append((center, radius))\n    \n    def is_in_collision(self, point: np.ndarray) -> bool:\n        """Check if a point is in collision with any obstacle"""\n        for center, radius in self.obstacles:\n            if np.linalg.norm(point - center) < radius:\n                return True\n        return False\n    \n    def is_valid_point(self, point: np.ndarray) -> bool:\n        """Check if point is within bounds and not in collision"""\n        for i, (min_val, max_val) in enumerate(self.bounds):\n            if not (min_val <= point[i] <= max_val):\n                return False\n        return not self.is_in_collision(point)\n    \n    def random_config(self) -> np.ndarray:\n        """Generate a random configuration within bounds"""\n        config = np.zeros(len(self.bounds))\n        for i, (min_val, max_val) in enumerate(self.bounds):\n            config[i] = random.uniform(min_val, max_val)\n        return config\n    \n    def nearest_node(self, point: np.ndarray) -> RRTNode:\n        """Find the nearest node in the tree to the given point"""\n        nearest = self.root\n        min_dist = np.linalg.norm(nearest.point - point)\n        \n        for node in self.nodes:\n            dist = np.linalg.norm(node.point - point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = node\n        \n        return nearest\n    \n    def extend_towards(self, from_node: RRTNode, target_point: np.ndarray) -> RRTNode:\n        """Extend the tree from a node towards a target point"""\n        direction = target_point - from_node.point\n        distance = np.linalg.norm(direction)\n        \n        if distance < self.step_size:\n            new_point = target_point.copy()\n        else:\n            direction = direction / distance  # Normalize\n            new_point = from_node.point + self.step_size * direction\n        \n        if self.is_valid_point(new_point):\n            new_node = RRTNode(new_point)\n            new_node.parent = from_node\n            from_node.children.append(new_node)\n            self.nodes.append(new_node)\n            return new_node\n        \n        return None\n    \n    def plan(self) -> List[np.ndarray]:\n        """Plan a path from start to goal using RRT"""\n        # Try to connect to goal occasionally\n        goal_bias = 0.05  # 5% chance to sample goal\n        \n        for _ in range(self.max_iterations):\n            # Randomly sample a point\n            if random.random() < goal_bias:\n                random_point = self.goal\n            else:\n                random_point = self.random_config()\n            \n            # Find nearest node and extend towards random point\n            nearest = self.nearest_node(random_point)\n            new_node = self.extend_towards(nearest, random_point)\n            \n            if new_node is not None:\n                # Try to connect to goal\n                goal_node = self.extend_towards(new_node, self.goal)\n                if goal_node is not None:\n                    # Check if we reached the goal\n                    if np.linalg.norm(goal_node.point - self.goal) < self.step_size:\n                        return self.extract_path(goal_node)\n        \n        return []  # Failed to find path\n    \n    def extract_path(self, goal_node: RRTNode) -> List[np.ndarray]:\n        """Extract path from goal node back to start"""\n        path = []\n        current = goal_node\n        while current:\n            path.append(current.point)\n            current = current.parent\n        return path[::-1]\n\n# Example usage\nstart = [0.0, 0.0]\ngoal = [5.0, 5.0]\nbounds = [(-1, 6), (-1, 6)]  # x and y bounds\n\nrrt = RRTPlanner(start, goal, bounds, max_iterations=5000, step_size=0.2)\nrrt.add_obstacle(np.array([2.5, 2.5]), 0.8)  # Add obstacle\npath = rrt.plan()\nprint(f"RRT found path with {len(path)} points" if path else "RRT failed to find path")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"navigation-in-dynamic-environments",children:"Navigation in Dynamic Environments"}),"\n",(0,a.jsx)(e.h3,{id:"dynamic-window-approach-dwa-implementation",children:"Dynamic Window Approach (DWA) Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\n@dataclass\nclass RobotState:\n    x: float\n    y: float\n    theta: float  # Heading angle\n    velocity: float  # Linear velocity\n    angular_velocity: float  # Angular velocity\n\nclass DWAPlanner:\n    def __init__(self, max_speed=1.0, min_speed=0.05,\n                 max_yaw_rate=40.0 * np.pi / 180.0,  # Convert to radians\n                 max_accel=0.5, max_delta_yaw_rate=40.0 * np.pi / 180.0,\n                 v_resolution=0.01, yaw_rate_resolution=0.1 * np.pi / 180.0,\n                 predict_time=3.0, to_goal_cost_gain=0.15, speed_cost_gain=1.0,\n                 obstacle_cost_gain=1.0, robot_radius=1.0):\n        \n        self.max_speed = max_speed\n        self.min_speed = min_speed\n        self.max_yaw_rate = max_yaw_rate\n        self.max_accel = max_accel\n        self.max_delta_yaw_rate = max_delta_yaw_rate\n        self.v_resolution = v_resolution\n        self.yaw_rate_resolution = yaw_rate_resolution\n        self.predict_time = predict_time\n        self.to_goal_cost_gain = to_goal_cost_gain\n        self.speed_cost_gain = speed_cost_gain\n        self.obstacle_cost_gain = obstacle_cost_gain\n        self.robot_radius = robot_radius\n\n    def plan(self, state: RobotState, goal: Tuple[float, float], obstacles: List[Tuple[float, float]]) -> Tuple[float, float]:\n        """Plan next velocities using Dynamic Window Approach"""\n        # Generate dynamic window\n        window = self.calc_dynamic_window(state)\n        \n        # Evaluate trajectories\n        best_trajectory = None\n        min_cost = float(\'inf\')\n        \n        # Sample velocities in the dynamic window\n        for v in np.arange(window[0], window[1], self.v_resolution):\n            for yaw_rate in np.arange(window[2], window[3], self.yaw_rate_resolution):\n                # Simulate trajectory\n                trajectory = self.predict_trajectory(state, v, yaw_rate)\n                \n                # Calculate costs\n                to_goal_cost = self.calc_to_goal_cost(trajectory, goal)\n                speed_cost = self.calc_speed_cost(trajectory)\n                obstacle_cost = self.calc_obstacle_cost(trajectory, obstacles)\n                \n                # Calculate total cost\n                final_cost = (self.to_goal_cost_gain * to_goal_cost +\n                             self.speed_cost_gain * speed_cost +\n                             self.obstacle_cost_gain * obstacle_cost)\n                \n                if final_cost < min_cost:\n                    min_cost = final_cost\n                    best_trajectory = trajectory\n        \n        if best_trajectory is not None:\n            return best_trajectory[0][3], best_trajectory[0][4]  # Return v, yaw_rate\n        else:\n            return 0.0, 0.0  # Stop if no valid trajectory found\n\n    def calc_dynamic_window(self, state: RobotState) -> List[float]:\n        """Calculate dynamic window based on current state and constraints"""\n        # [v_min, v_max, yaw_rate_min, yaw_rate_max]\n        window = [\n            max(self.min_speed, state.velocity - self.max_accel * 0.1),\n            min(self.max_speed, state.velocity + self.max_accel * 0.1),\n            max(-self.max_yaw_rate, state.angular_velocity - self.max_delta_yaw_rate * 0.1),\n            min(self.max_yaw_rate, state.angular_velocity + self.max_delta_yaw_rate * 0.1)\n        ]\n        return window\n\n    def predict_trajectory(self, state: RobotState, v: float, yaw_rate: float) -> List[List[float]]:\n        """Predict trajectory with constant velocity and yaw rate"""\n        trajectory = []\n        time = 0\n        current_state = RobotState(state.x, state.y, state.theta, v, yaw_rate)\n        \n        while time <= self.predict_time:\n            trajectory.append([current_state.x, current_state.y, current_state.theta, \n                              current_state.velocity, current_state.angular_velocity])\n            \n            current_state.x += current_state.velocity * np.cos(current_state.theta) * 0.1\n            current_state.y += current_state.velocity * np.sin(current_state.theta) * 0.1\n            current_state.theta += current_state.angular_velocity * 0.1\n            current_state.velocity = v\n            current_state.angular_velocity = yaw_rate\n            \n            time += 0.1\n        \n        return trajectory\n\n    def calc_to_goal_cost(self, trajectory: List[List[float]], goal: Tuple[float, float]) -> float:\n        """Calculate cost for distance to goal"""\n        if not trajectory:\n            return float(\'inf\')\n        \n        dx = goal[0] - trajectory[-1][0]\n        dy = goal[1] - trajectory[-1][1]\n        error_angle = np.arctan2(dy, dx)\n        cost_angle = error_angle - trajectory[-1][2]\n        cost = abs(np.arctan2(np.sin(cost_angle), np.cos(cost_angle)))\n        \n        return cost\n\n    def calc_speed_cost(self, trajectory: List[List[float]]) -> float:\n        """Calculate cost for speed (prefer higher speeds)"""\n        if not trajectory:\n            return float(\'inf\')\n        \n        speed_cost = self.max_speed - trajectory[0][3]\n        return speed_cost\n\n    def calc_obstacle_cost(self, trajectory: List[List[float]], obstacles: List[Tuple[float, float]]) -> float:\n        """Calculate cost for obstacle proximity"""\n        if not trajectory:\n            return float(\'inf\')\n        \n        min_dist = float(\'inf\')\n        for i in range(len(trajectory)):\n            for (ox, oy) in obstacles:\n                dist = np.sqrt((trajectory[i][0] - ox)**2 + (trajectory[i][1] - oy)**2)\n                if dist <= self.robot_radius:\n                    return float(\'inf\')  # Collision\n                if dist < min_dist:\n                    min_dist = dist\n        \n        return 1.0 / min_dist if min_dist != float(\'inf\') else float(\'inf\')\n\n# Example usage\ndwa = DWAPlanner()\nstate = RobotState(0, 0, 0, 0, 0)\ngoal = (5.0, 5.0)\nobstacles = [(2, 2), (3, 3), (4, 4)]\nv, yaw_rate = dwa.plan(state, goal, obstacles)\nprint(f"DWA suggests velocity: {v:.3f}, angular velocity: {yaw_rate:.3f}")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"implementing-path-optimization",children:"Implementing Path Optimization"}),"\n",(0,a.jsx)(e.h3,{id:"path-smoothing-with-b-splines",children:"Path Smoothing with B-Splines"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.interpolate import BSpline\nimport matplotlib.pyplot as plt\n\ndef bspline_smooth_path(path_points: List[Tuple[float, float]], smoothing_factor: float = 0.1):\n    """Smooth a path using B-splines"""\n    if len(path_points) < 3:\n        return path_points\n    \n    # Extract x and y coordinates\n    x_coords = [p[0] for p in path_points]\n    y_coords = [p[1] for p in path_points]\n    n_points = len(path_points)\n    \n    # Create parameter vector\n    t = np.linspace(0, 1, n_points)\n    \n    # Add some padding to the path for better smoothing\n    # This avoids sharp turns at endpoints\n    if len(x_coords) >= 4:\n        # Use cubic splines (degree 3)\n        degree = 3\n        n_knots = max(len(x_coords) - degree, 1)\n        t_knots = np.linspace(0, 1, n_knots)\n        \n        # Extend the knot vector to have appropriate multiplicity at the ends\n        t_knots = np.concatenate(([0]*degree, t_knots, [1]*degree))\n        \n        # Calculate spline coefficients using least squares\n        x_coeff = np.linalg.lstsq(BSpline.design_matrix(t, t_knots, degree).toarray(), x_coords, rcond=None)[0]\n        y_coeff = np.linalg.lstsq(BSpline.design_matrix(t, t_knots, degree).toarray(), y_coords, rcond=None)[0]\n        \n        # Create new parameter vector with more points for smooth output\n        t_smooth = np.linspace(0, 1, 3 * n_points)\n        \n        # Evaluate the splines\n        bs_x = BSpline(t_knots, x_coeff, degree)\n        bs_y = BSpline(t_knots, y_coeff, degree)\n        \n        smooth_x = bs_x(t_smooth)\n        smooth_y = bs_y(t_smooth)\n        \n        return [(smooth_x[i], smooth_y[i]) for i in range(len(smooth_x))]\n    else:\n        # For short paths, just return original\n        return path_points\n\ndef path_optimizer(original_path: List[Tuple[float, float]], grid_map: np.ndarray):\n    """Optimize path for smoothness and obstacle avoidance"""\n    # First smooth the path\n    smoothed_path = bspline_smooth_path(original_path)\n    \n    # Then check for collisions and adjust if necessary\n    optimized_path = []\n    for point in smoothed_path:\n        x, y = point\n        grid_x, grid_y = int(x), int(y)\n        \n        # Check if this point is valid\n        if (0 <= grid_x < grid_map.shape[0] and \n            0 <= grid_y < grid_map.shape[1] and \n            grid_map[grid_x, grid_y] == 0):\n            optimized_path.append(point)\n        else:\n            # If in collision, try to find a nearby valid point\n            # This is a simple approach - more sophisticated methods exist\n            found_valid = False\n            for dx in range(-2, 3):\n                for dy in range(-2, 3):\n                    new_x, new_y = grid_x + dx, grid_y + dy\n                    if (0 <= new_x < grid_map.shape[0] and \n                        0 <= new_y < grid_map.shape[1] and \n                        grid_map[new_x, new_y] == 0):\n                        optimized_path.append((new_x, new_y))\n                        found_valid = True\n                        break\n                if found_valid:\n                    break\n            \n            if not found_valid:\n                # If no valid point found nearby, add original point (will have collision issue)\n                optimized_path.append(point)\n    \n    return optimized_path\n'})}),"\n",(0,a.jsx)(e.h2,{id:"implementing-footstep-planning-for-bipedal-navigation",children:"Implementing Footstep Planning for Bipedal Navigation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\n\nclass FootstepPlanner:\n    def __init__(self, step_length=0.3, step_width=0.2, max_step_angular=0.3):\n        self.step_length = step_length  # Forward step distance\n        self.step_width = step_width    # Lateral step distance\n        self.max_step_angular = max_step_angular  # Max angular change per step (radians)\n        self.min_step_angular = -max_step_angular\n    \n    def plan_footsteps(self, \n                      start_pos: Tuple[float, float, float],  # (x, y, theta)\n                      goal_pos: Tuple[float, float, float],   # (x, y, theta)\n                      grid_map: np.ndarray) -> List[Tuple[float, float, float]]:\n        """\n        Plan a sequence of footsteps from start to goal for a bipedal robot\n        Returns list of (x, y, theta) for each footstep\n        """\n        footsteps = []\n        current_pos = np.array(start_pos, dtype=float)\n        goal = np.array(goal_pos)\n        \n        # Simple RRT-like approach for footstep planning\n        max_iterations = 1000\n        goal_reached_threshold = 0.2\n        \n        for i in range(max_iterations):\n            # Check if we\'re close enough to goal\n            pos_diff = goal[:2] - current_pos[:2]\n            dist_to_goal = np.linalg.norm(pos_diff)\n            \n            if dist_to_goal < goal_reached_threshold and abs(goal[2] - current_pos[2]) < self.max_step_angular:\n                # Add final position to footsteps\n                footsteps.append(tuple(current_pos))\n                break\n            \n            # Determine next step direction\n            if dist_to_goal > self.step_length:\n                # Move toward goal\n                direction = pos_diff / dist_to_goal\n                step_vector = self.step_length * direction\n            else:\n                # Move directly to goal\n                step_vector = pos_diff\n            \n            # Generate potential step\n            next_pos = current_pos.copy()\n            next_pos[0] += step_vector[0]\n            next_pos[1] += step_vector[1]\n            \n            # Adjust orientation\n            target_orientation = np.arctan2(step_vector[1], step_vector[0])\n            orientation_diff = target_orientation - current_pos[2]\n            \n            # Limit orientation change per step\n            if orientation_diff > self.max_step_angular:\n                next_pos[2] = current_pos[2] + self.max_step_angular\n            elif orientation_diff < self.min_step_angular:\n                next_pos[2] = current_pos[2] + self.min_step_angular\n            else:\n                next_pos[2] = target_orientation\n            \n            # Check if the new position is valid\n            grid_x, grid_y = int(next_pos[0]), int(next_pos[1])\n            if self.is_valid_footstep((grid_x, grid_y), grid_map):\n                footsteps.append(tuple(next_pos))\n                current_pos = next_pos\n            else:\n                # If the step is invalid, try to find an alternative\n                # This is a simplified approach - more sophisticated methods would do proper replanning\n                print(f"Invalid step at {(grid_x, grid_y)}, stopping planning.")\n                break\n        \n        return footsteps\n    \n    def is_valid_footstep(self, pos: Tuple[int, int], grid_map: np.ndarray) -> bool:\n        """Check if a footstep position is valid (not in collision)"""\n        x, y = pos\n        if x < 0 or x >= grid_map.shape[0] or y < 0 or y >= grid_map.shape[1]:\n            return False\n        \n        # Check if the grid cell is free\n        if grid_map[x, y] != 0:\n            return False\n        \n        # Additional checks could go here (terrain stability, etc.)\n        return True\n\n# Example usage\nfootstep_planner = FootstepPlanner()\ngrid = np.zeros((20, 20))\ngrid[10, 5:15] = 1  # Add an obstacle\nstart = (1, 10, 0)  # Start position and orientation\ngoal = (18, 10, 0)  # Goal position and orientation\nfootsteps = footstep_planner.plan_footsteps(start, goal, grid)\nprint(f"Planned {len(footsteps)} footsteps")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"integration-complete-navigation-system",children:"Integration: Complete Navigation System"}),"\n",(0,a.jsx)(e.h3,{id:"navigation-stack-implementation",children:"Navigation Stack Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport time\nfrom typing import List, Tuple, Optional\nimport threading\n\nclass NavigationSystem:\n    def __init__(self, grid_map: np.ndarray):\n        self.grid_map = grid_map\n        self.global_planner = AStarPlanner(grid_map)\n        self.local_planner = DWAPlanner()\n        self.footstep_planner = FootstepPlanner()\n        \n        # Robot state\n        self.current_position = (0, 0)\n        self.current_orientation = 0.0\n        self.current_velocity = 0.0\n        \n        # Navigation state\n        self.goal_position: Optional[Tuple[float, float]] = None\n        self.global_path: List[Tuple[float, float]] = []\n        self.current_waypoint_idx = 0\n        self.is_navigating = False\n        \n        # Control parameters\n        self.waypoint_threshold = 0.5\n        self.navigation_frequency = 10  # Hz\n        self.control_thread = None\n        \n    def set_goal(self, goal: Tuple[float, float]):\n        """Set navigation goal"""\n        self.goal_position = goal\n        \n        # Plan global path\n        start = self.current_position\n        self.global_path = self.global_planner.plan_path(start, goal)\n        self.current_waypoint_idx = 0\n        \n        print(f"Global path planned with {len(self.global_path)} waypoints")\n        \n    def update_robot_position(self, new_pos: Tuple[float, float], orientation: float = 0.0):\n        """Update robot\'s current position and orientation"""\n        self.current_position = new_pos\n        self.current_orientation = orientation\n    \n    def distance_to_waypoint(self, waypoint: Tuple[float, float]) -> float:\n        """Calculate distance to a waypoint"""\n        dx = waypoint[0] - self.current_position[0]\n        dy = waypoint[1] - self.current_position[1]\n        return np.sqrt(dx**2 + dy**2)\n    \n    def navigate_to_goal(self):\n        """Main navigation loop"""\n        if self.goal_position is None or not self.global_path:\n            print("No goal set or path planned!")\n            return\n        \n        self.is_navigating = True\n        dt = 1.0 / self.navigation_frequency\n        \n        while self.current_waypoint_idx < len(self.global_path) and self.is_navigating:\n            current_waypoint = self.global_path[self.current_waypoint_idx]\n            \n            # Check if we\'ve reached the current waypoint\n            if self.distance_to_waypoint(current_waypoint) < self.waypoint_threshold:\n                self.current_waypoint_idx += 1\n                if self.current_waypoint_idx < len(self.global_path):\n                    print(f"Reached waypoint {self.current_waypoint_idx}, moving to next...")\n                else:\n                    print("Reached final goal!")\n                    break\n            \n            # Perform local planning and obstacle avoidance\n            # In a real system, this would use current sensor data\n            obstacles = self.get_obstacles()  # Would come from sensors\n            robot_state = RobotState(\n                self.current_position[0], \n                self.current_position[1], \n                self.current_orientation,\n                self.current_velocity, \n                0.0\n            )\n            \n            # Use DWA for local navigation\n            v_cmd, yaw_rate_cmd = self.local_planner.plan(\n                robot_state, \n                current_waypoint, \n                obstacles\n            )\n            \n            # In a real system, send commands to robot actuators here\n            self.execute_control_commands(v_cmd, yaw_rate_cmd)\n            \n            # Update position based on commands (simulation)\n            self.simulate_motion_update(v_cmd, yaw_rate_cmd, dt)\n            \n            time.sleep(dt)\n        \n        self.is_navigating = False\n    \n    def get_obstacles(self) -> List[Tuple[float, float]]:\n        """Get obstacle positions from sensors (simulated)"""\n        # In a real system, this would come from range sensors, cameras, etc.\n        # For simulation, return some fixed obstacles\n        return [(5, 5), (6, 6), (7, 7)]\n    \n    def execute_control_commands(self, v_cmd: float, yaw_rate_cmd: float):\n        """Execute velocity and angular velocity commands"""\n        # This would interface with the robot\'s motor control system\n        # For simulation purposes, print the commands\n        print(f"Commanding: v={v_cmd:.3f}, yaw_rate={yaw_rate_cmd:.3f}")\n    \n    def simulate_motion_update(self, v_cmd: float, yaw_rate_cmd: float, dt: float):\n        """Simulate robot motion based on commands"""\n        # Update position based on velocity commands\n        new_x = self.current_position[0] + v_cmd * np.cos(self.current_orientation) * dt\n        new_y = self.current_position[1] + v_cmd * np.sin(self.current_orientation) * dt\n        new_theta = self.current_orientation + yaw_rate_cmd * dt\n        \n        self.current_position = (new_x, new_y)\n        self.current_orientation = new_theta\n        self.current_velocity = v_cmd\n    \n    def start_navigation(self):\n        """Start navigation in a separate thread"""\n        if self.control_thread is None or not self.control_thread.is_alive():\n            self.control_thread = threading.Thread(target=self.navigate_to_goal)\n            self.control_thread.start()\n    \n    def stop_navigation(self):\n        """Stop the navigation process"""\n        self.is_navigating = False\n        if self.control_thread:\n            self.control_thread.join()\n\n# Example usage\ngrid = np.zeros((20, 20))\ngrid[10, 5:15] = 1  # Add an obstacle\nnav_system = NavigationSystem(grid)\n\n# Set start and goal\nnav_system.update_robot_position((1, 1))\nnav_system.set_goal((18, 18))\n\n# Start navigation\nnav_system.start_navigation()\n\n# Let it run for a bit, then stop\ntime.sleep(10)\nnav_system.stop_navigation()\n'})}),"\n",(0,a.jsx)(e.h2,{id:"real-time-navigation-considerations",children:"Real-time Navigation Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"performance-optimization-techniques",children:"Performance Optimization Techniques"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import time\nimport numpy as np\nfrom collections import deque\n\nclass RealtimeNavigationSystem:\n    def __init__(self):\n        self.update_times = deque(maxlen=100)  # Keep last 100 update times\n        self.target_frequency = 10  # Hz\n        self.dt = 1.0 / self.target_frequency\n        \n        # Caching for expensive computations\n        self.path_cache = {}\n        self.kd_tree = None  # For nearest neighbor searches\n        \n        # Multi-resolution maps for different planning needs\n        self.maps = {\n            \'global\': None,  # Low resolution for global planning\n            \'local\': None,   # High resolution for local navigation\n        }\n    \n    def plan_with_timeout(self, planner_func, timeout=0.1):\n        """Plan path with a timeout to ensure real-time performance"""\n        start_time = time.time()\n        \n        try:\n            result = planner_func()\n        except:\n            result = []\n        \n        elapsed = time.time() - start_time\n        self.update_times.append(elapsed)\n        \n        if elapsed > timeout:\n            print(f"Planning took {elapsed:.3f}s, which exceeds timeout of {timeout}s")\n        \n        return result\n    \n    def get_average_update_time(self):\n        """Get average update time for performance monitoring"""\n        if self.update_times:\n            return sum(self.update_times) / len(self.update_times)\n        return 0.0\n    \n    def is_realtime_capable(self):\n        """Check if system is meeting real-time requirements"""\n        avg_time = self.get_average_update_time()\n        return avg_time < (0.8 * self.dt)  # 80% of cycle time\n'})}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(e.p,{children:"This chapter provided practical implementations of motion planning and navigation algorithms for humanoid robots. We covered grid-based planning (A*), sampling-based methods (RRT), dynamic environment navigation (DWA), and complete navigation systems."}),"\n",(0,a.jsx)(e.p,{children:"The implementations in this chapter demonstrate how theoretical concepts translate into working code that can be deployed on humanoid robots. The examples include path optimization, footstep planning, and integration into complete navigation systems. These implementations can be adapted and extended for specific robot platforms and applications."}),"\n",(0,a.jsx)(e.p,{children:"The algorithms discussed here form the foundation for creating autonomous humanoid robots that can navigate complex environments safely and efficiently. In practice, these systems need to be tuned for specific hardware, integrated with perception systems, and validated through extensive testing."})]})}function c(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>r});var a=t(6540);const o={},i=a.createContext(o);function s(n){const e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);