"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[779],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var t=i(6540);const o={},r=t.createContext(o);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},9039:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=i(4848),o=i(8453);const r={},l="Chapter 3: Theoretical Foundations of Motor Control and Actuation",a={id:"textbook/chapter3/theory",title:"Chapter 3: Theoretical Foundations of Motor Control and Actuation",description:"Mathematical Models for Motor Control",source:"@site/docs/textbook/chapter3/theory.md",sourceDirName:"textbook/chapter3",slug:"/textbook/chapter3/theory",permalink:"/Ai-book/docs/textbook/chapter3/theory",draft:!1,unlisted:!1,editUrl:"https://github.com/AftabAhmed4/Ai-book/edit/main/docs/textbook/chapter3/theory.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Chapter 3: Motor Control and Actuation Systems",permalink:"/Ai-book/docs/textbook/chapter3/intro"},next:{title:"Chapter 3: Practical Applications of Motor Control and Actuation",permalink:"/Ai-book/docs/textbook/chapter3/practical"}},s={},c=[{value:"Mathematical Models for Motor Control",id:"mathematical-models-for-motor-control",level:2},{value:"3.1 Robot Kinematics",id:"31-robot-kinematics",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"3.2 Robot Dynamics",id:"32-robot-dynamics",level:2},{value:"Lagrangian Formulation",id:"lagrangian-formulation",level:3},{value:"Inertia Matrix",id:"inertia-matrix",level:3},{value:"3.3 Control Theory for Motor Systems",id:"33-control-theory-for-motor-systems",level:2},{value:"PID Control",id:"pid-control",level:3},{value:"State-Space Representation",id:"state-space-representation",level:3},{value:"Linear Quadratic Regulator (LQR)",id:"linear-quadratic-regulator-lqr",level:3},{value:"3.4 Balance and Stability Theory",id:"34-balance-and-stability-theory",level:2},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Capture Point (Capture Point)",id:"capture-point-capture-point",level:3},{value:"3.5 Control Strategies",id:"35-control-strategies",level:2},{value:"Operational Space Control",id:"operational-space-control",level:3},{value:"Impedance Control",id:"impedance-control",level:3},{value:"Admittance Control",id:"admittance-control",level:3},{value:"3.6 Optimization-Based Control",id:"36-optimization-based-control",level:2},{value:"Quadratic Programming (QP) Formulation",id:"quadratic-programming-qp-formulation",level:3},{value:"3.7 Advanced Control Concepts",id:"37-advanced-control-concepts",level:2},{value:"Adaptive Control",id:"adaptive-control",level:3},{value:"Sliding Mode Control",id:"sliding-mode-control",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"3.8 Actuator Models",id:"38-actuator-models",level:2},{value:"DC Motor Model",id:"dc-motor-model",level:3},{value:"Series Elastic Actuator (SEA) Model",id:"series-elastic-actuator-sea-model",level:3},{value:"3.9 Stability Analysis",id:"39-stability-analysis",level:2},{value:"Lyapunov Stability",id:"lyapunov-stability",level:3},{value:"Passivity Theory",id:"passivity-theory",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"chapter-3-theoretical-foundations-of-motor-control-and-actuation",children:"Chapter 3: Theoretical Foundations of Motor Control and Actuation"}),"\n",(0,t.jsx)(n.h2,{id:"mathematical-models-for-motor-control",children:"Mathematical Models for Motor Control"}),"\n",(0,t.jsx)(n.p,{children:"Motor control in humanoid robotics requires mathematical models that accurately describe the complex dynamics of multi-link systems. These models form the foundation for control algorithms that enable stable, efficient, and dexterous robot motion."}),"\n",(0,t.jsx)(n.h2,{id:"31-robot-kinematics",children:"3.1 Robot Kinematics"}),"\n",(0,t.jsx)(n.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,t.jsx)(n.p,{children:"For an n-DOF robot manipulator with joint angles \u03b8 = [\u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099]\u1d40, the forward kinematics maps joint space to Cartesian space:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"p = f(\u03b8)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where p represents the end-effector position and orientation."}),"\n",(0,t.jsx)(n.p,{children:"For a serial chain of links, this is computed using the Denavit-Hartenberg (DH) parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"T = A\u2081(\u03b8\u2081) \xd7 A\u2082(\u03b8\u2082) \xd7 ... \xd7 A\u2099(\u03b8\u2099)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where A\u1d62 represents the transformation matrix for the i-th joint."}),"\n",(0,t.jsx)(n.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,t.jsx)(n.p,{children:"The inverse kinematics problem seeks to find joint angles that achieve a desired end-effector pose:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u03b8 = f\u207b\xb9(p)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is often solved using:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analytical solutions"}),": For simple kinematic chains"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Iterative methods"}),": Jacobian-based approaches like Newton-Raphson"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The Jacobian matrix J(\u03b8) relates joint velocities to end-effector velocities:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u1e57 = J(\u03b8)\u03b8\u0307\n"})}),"\n",(0,t.jsx)(n.p,{children:"For inverse kinematics: \u03b8\u0307 = J\u207a\u1e57, where J\u207a is the pseudoinverse of J."}),"\n",(0,t.jsx)(n.h2,{id:"32-robot-dynamics",children:"3.2 Robot Dynamics"}),"\n",(0,t.jsx)(n.h3,{id:"lagrangian-formulation",children:"Lagrangian Formulation"}),"\n",(0,t.jsx)(n.p,{children:"The dynamics of an n-DOF robot are described by the Lagrange equation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u03c4 = M(\u03b8)\u03b8\u0308 + C(\u03b8,\u03b8\u0307)\u03b8\u0307 + g(\u03b8) + J\u1d40F_ext\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u03c4 is the vector of joint torques"}),"\n",(0,t.jsx)(n.li,{children:"M(\u03b8) is the inertia matrix"}),"\n",(0,t.jsx)(n.li,{children:"C(\u03b8,\u03b8\u0307) is the Coriolis and centrifugal force matrix"}),"\n",(0,t.jsx)(n.li,{children:"g(\u03b8) is the gravity vector"}),"\n",(0,t.jsx)(n.li,{children:"F_ext represents external forces"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"inertia-matrix",children:"Inertia Matrix"}),"\n",(0,t.jsx)(n.p,{children:"The inertia matrix M(\u03b8) is computed as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"M(\u03b8) = \u03a3\u1d62 m\u1d62J\u1d65\u1d62\u1d40J\u1d65\u1d62 + \u03a3\u1d62 J\u03c9\u1d62\u1d40I\u1d62J\u03c9\u1d62\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"J\u1d65\u1d62 is the linear velocity Jacobian for link i"}),"\n",(0,t.jsx)(n.li,{children:"J\u03c9\u1d62 is the angular velocity Jacobian for link i"}),"\n",(0,t.jsx)(n.li,{children:"I\u1d62 is the inertia tensor for link i"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"33-control-theory-for-motor-systems",children:"3.3 Control Theory for Motor Systems"}),"\n",(0,t.jsx)(n.h3,{id:"pid-control",children:"PID Control"}),"\n",(0,t.jsx)(n.p,{children:"The Proportional-Integral-Derivative controller is fundamental in motor control:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"u(t) = K\u209ae(t) + K\u1d62\u222be(\u03c4)d\u03c4 + Kd de(t)/dt\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"u(t) is the control output"}),"\n",(0,t.jsx)(n.li,{children:"e(t) is the error signal"}),"\n",(0,t.jsx)(n.li,{children:"K\u209a, K\u1d62, Kd are control gains"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In discrete form:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"u[k] = K\u209ae[k] + K\u1d62\u2211e[i] + Kd(e[k] - e[k-1])\n"})}),"\n",(0,t.jsx)(n.h3,{id:"state-space-representation",children:"State-Space Representation"}),"\n",(0,t.jsx)(n.p,{children:"Robot dynamics can be expressed in state-space form:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u1e8b = f(x, u)\ny = h(x)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where x is the state vector [\u03b8 \u03b8\u0307]\u1d40, u is the control input, and y is the output."}),"\n",(0,t.jsx)(n.h3,{id:"linear-quadratic-regulator-lqr",children:"Linear Quadratic Regulator (LQR)"}),"\n",(0,t.jsx)(n.p,{children:"For linearized systems, LQR provides optimal control by minimizing a quadratic cost function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"J = \u222b[x\u1d40Qx + u\u1d40Ru] dt\n"})}),"\n",(0,t.jsx)(n.p,{children:"The optimal control law is u = -Kx, where K is computed using the Riccati equation."}),"\n",(0,t.jsx)(n.h2,{id:"34-balance-and-stability-theory",children:"3.4 Balance and Stability Theory"}),"\n",(0,t.jsx)(n.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,t.jsx)(n.p,{children:"For a robot in planar motion, the ZMP is the point on the ground where the net moment of the ground reaction force is zero:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"x_ZMP = x_COM - h/g * \u1e8d_COM\ny_ZMP = y_COM - h/g * \xff_COM\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"(x_COM, y_COM, h) is the center of mass position"}),"\n",(0,t.jsx)(n.li,{children:"g is gravitational acceleration"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For stable walking, the ZMP must remain within the support polygon."}),"\n",(0,t.jsx)(n.h3,{id:"capture-point-capture-point",children:"Capture Point (Capture Point)"}),"\n",(0,t.jsx)(n.p,{children:"The capture point is where the robot can step to stop safely:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"x_CP = x_COM + \u1e8b_COM/\u03c9\ny_CP = y_COM + \u1e8f_COM/\u03c9\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where \u03c9 = \u221a(g/h) is the natural frequency of a linear inverted pendulum."}),"\n",(0,t.jsx)(n.h2,{id:"35-control-strategies",children:"3.5 Control Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"operational-space-control",children:"Operational Space Control"}),"\n",(0,t.jsx)(n.p,{children:"In operational space control, we control forces and motions in Cartesian space directly:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"F = \u039b(x)\u1e8d + \u03bc(x, \u1e8b)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u039b(x) = (J M\u207b\xb9 J\u1d40)\u207b\xb9 is the operational space inertia matrix"}),"\n",(0,t.jsx)(n.li,{children:"\u03bc(x, \u1e8b) = J M\u207b\xb9(C\u03b8\u0307 + g) - J\u0307\u03b8\u0307 is the Coriolis and gravity term in operational space"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,t.jsx)(n.p,{children:"Impedance control regulates the mechanical impedance of the robot:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"M_d(\u1e8d_d - \u1e8d) + B_d(\u1e8b_d - \u1e8b) + K_d(x_d - x) = F\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"M_d, B_d, K_d are desired mass, damping, and stiffness matrices"}),"\n",(0,t.jsx)(n.li,{children:"x_d, \u1e8b_d, \u1e8d_d are desired position, velocity, and acceleration"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"admittance-control",children:"Admittance Control"}),"\n",(0,t.jsx)(n.p,{children:"Admittance control relates motion to applied force:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"M_a(\u1e8d - \u1e8d_ref) + B_a(\u1e8b - \u1e8b_ref) + K_a(x - x_ref) = F\n"})}),"\n",(0,t.jsx)(n.h2,{id:"36-optimization-based-control",children:"3.6 Optimization-Based Control"}),"\n",(0,t.jsx)(n.h3,{id:"quadratic-programming-qp-formulation",children:"Quadratic Programming (QP) Formulation"}),"\n",(0,t.jsx)(n.p,{children:"Many control problems can be formulated as QP:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"min \xbdx\u1d40Hx + f\u1d40x\ns.t. Ax \u2264 b\n     A_eq x = b_eq\n"})}),"\n",(0,t.jsx)(n.p,{children:"For motor control, this might optimize torque distribution across redundant actuators while satisfying constraints."}),"\n",(0,t.jsx)(n.h2,{id:"37-advanced-control-concepts",children:"3.7 Advanced Control Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"adaptive-control",children:"Adaptive Control"}),"\n",(0,t.jsx)(n.p,{children:"Adaptive control adjusts controller parameters in real-time to handle unknown or changing dynamics:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u03c4 = Y(\u03b8,\u03b8\u0307,\u03b8\u0308)\u03b8\u0302 + K_v(\u03b8\u0307_r - \u03b8\u0307) + K_p(\u03b8_r - \u03b8)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where \u0177 is the parameter estimate and \u03b8\u0307_r = \u03b8\u0307_d - \u03bb(\u03b8 - \u03b8_d) is the filtered tracking error."}),"\n",(0,t.jsx)(n.h3,{id:"sliding-mode-control",children:"Sliding Mode Control"}),"\n",(0,t.jsx)(n.p,{children:"Sliding mode control forces the system state to follow a predefined sliding surface:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"s = \u0117 + \u03bbe\n"})}),"\n",(0,t.jsx)(n.p,{children:"The control law ensures \u0117 approaches the sliding surface s = 0."}),"\n",(0,t.jsx)(n.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,t.jsx)(n.p,{children:"MPC solves an optimization problem at each time step over a prediction horizon:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"min \u2211[l(x_k, u_k) + l_f(x_N)]\ns.t. x_{k+1} = f(x_k, u_k)\n     x_min \u2264 x_k \u2264 x_max\n     u_min \u2264 u_k \u2264 u_max\n"})}),"\n",(0,t.jsx)(n.h2,{id:"38-actuator-models",children:"3.8 Actuator Models"}),"\n",(0,t.jsx)(n.h3,{id:"dc-motor-model",children:"DC Motor Model"}),"\n",(0,t.jsx)(n.p,{children:"A DC motor can be modeled as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"V = R_a i_a + L_a di_a/dt + K_e \u03c9\nT = K_t i_a\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"V is applied voltage"}),"\n",(0,t.jsx)(n.li,{children:"i_a is armature current"}),"\n",(0,t.jsx)(n.li,{children:"R_a, L_a are armature resistance and inductance"}),"\n",(0,t.jsx)(n.li,{children:"K_e, K_t are back-emf and torque constants"}),"\n",(0,t.jsx)(n.li,{children:"\u03c9 is angular velocity"}),"\n",(0,t.jsx)(n.li,{children:"T is output torque"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"series-elastic-actuator-sea-model",children:"Series Elastic Actuator (SEA) Model"}),"\n",(0,t.jsx)(n.p,{children:"The SEA model includes a spring element:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"J_m \u03b8\u0308_m + B_m \u03b8\u0307_m = \u03c4_m - K_s(\u03b8_m - \u03b8_l)\nJ_l \u03b8\u0308_l + B_l \u03b8\u0307_l = K_s(\u03b8_m - \u03b8_l) - \u03c4_L\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where subscripts m and l refer to motor and load, respectively."}),"\n",(0,t.jsx)(n.h2,{id:"39-stability-analysis",children:"3.9 Stability Analysis"}),"\n",(0,t.jsx)(n.h3,{id:"lyapunov-stability",children:"Lyapunov Stability"}),"\n",(0,t.jsx)(n.p,{children:"A system is stable if there exists a Lyapunov function V(x) such that:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"V(0) = 0 and V(x) > 0 for all x \u2260 0"}),"\n",(0,t.jsx)(n.li,{children:"V\u0307(x) \u2264 0 for all x (negative semi-definite)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"passivity-theory",children:"Passivity Theory"}),"\n",(0,t.jsx)(n.p,{children:"A system is passive if:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u222b\u2080\u1d40 u\u1d40(t)y(t)dt \u2265 -\u03b2\n"})}),"\n",(0,t.jsx)(n.p,{children:"Passive systems are stable when connected in feedback with other passive systems."}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The theoretical foundations of motor control provide the mathematical tools needed to develop sophisticated control systems for humanoid robots. Understanding these concepts is essential for designing controllers that can achieve stable, efficient, and dexterous robot motion. The mathematical models presented here form the basis for advanced control strategies that enable humanoid robots to perform complex tasks in real-world environments."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);