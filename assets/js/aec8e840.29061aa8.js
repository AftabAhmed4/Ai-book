"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[619],{5886:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=i(4848),t=i(8453);const a={},o="Chapter 4: Exercises and Problems",r={id:"textbook/chapter4/exercises",title:"Chapter 4: Exercises and Problems",description:"Conceptual Questions",source:"@site/docs/textbook/chapter4/exercises.md",sourceDirName:"textbook/chapter4",slug:"/textbook/chapter4/exercises",permalink:"/Ai-book/docs/textbook/chapter4/exercises",draft:!1,unlisted:!1,editUrl:"https://github.com/AftabAhmed4/Ai-book/edit/main/docs/textbook/chapter4/exercises.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Chapter 4: Practical Applications of Motion Planning and Navigation",permalink:"/Ai-book/docs/textbook/chapter4/practical"},next:{title:"Chapter 5: Human-Robot Interaction and Social Robotics",permalink:"/Ai-book/docs/textbook/chapter5/intro"}},l={},c=[{value:"Conceptual Questions",id:"conceptual-questions",level:2},{value:"Mathematical Problems",id:"mathematical-problems",level:2},{value:"Programming Exercises",id:"programming-exercises",level:2},{value:"Design Problems",id:"design-problems",level:2},{value:"Simulation Exercises",id:"simulation-exercises",level:2},{value:"Analysis Problems",id:"analysis-problems",level:2},{value:"Research and Investigation",id:"research-and-investigation",level:2},{value:"Practical Implementation Challenge",id:"practical-implementation-challenge",level:2},{value:"Advanced Problems",id:"advanced-problems",level:2},{value:"Discussion Questions",id:"discussion-questions",level:2},{value:"Solutions and Hints",id:"solutions-and-hints",level:2},{value:"Problem 2 Solution Outline:",id:"problem-2-solution-outline",level:3},{value:"Problem 5 Solution Outline:",id:"problem-5-solution-outline",level:3},{value:"Programming Exercise 1 Hints:",id:"programming-exercise-1-hints",level:3}];function h(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"chapter-4-exercises-and-problems",children:"Chapter 4: Exercises and Problems"}),"\n",(0,s.jsx)(e.h2,{id:"conceptual-questions",children:"Conceptual Questions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Compare and contrast"})," sampling-based planners (RRT, PRM) with grid-based planners (A*, Dijkstra). What are the advantages and limitations of each approach for humanoid robot navigation?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Explain"})," the concept of configuration space and how obstacles in the workspace translate to the configuration space for a multi-degree-of-freedom robot."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Analyze"})," the differences between global path planning and local path planning (reactive navigation). When would you use each approach?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Discuss"})," the challenges of motion planning for humanoid robots compared to wheeled robots. How do balance and bipedal locomotion constraints affect planning?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Evaluate"})," the trade-offs between optimality and computational efficiency in path planning algorithms. Why might a suboptimal but fast algorithm be preferred in some applications?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"mathematical-problems",children:"Mathematical Problems"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Configuration Space"}),": For a 2-DOF planar manipulator with link lengths L\u2081 = 1m, L\u2082 = 0.5m, and an obstacle at (1.5, 0.5) with radius 0.2m, determine if the configuration \u03b8\u2081 = \u03c0/4, \u03b8\u2082 = \u03c0/2 is in C_free or C_obst."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.em,{children:[(0,s.jsx)(e.em,{children:"A"})," Path Cost"]}),"*: In a 10x10 grid where each cell has a movement cost of 1 (horizontal/vertical) and 1.414 (diagonal), use A* to find the path from (0,0) to (5,5) with an obstacle at (3,3). What is the total path cost?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"RRT Probability"}),": If an RRT algorithm has explored 1000 nodes in a 2D space with a free space area of 50m\xb2, what is the probability that a randomly sampled point is within 0.5m of an existing node?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Velocity Obstacle"}),": A robot at position (0,0) with maximum speed of 1 m/s needs to avoid a moving obstacle at (2,0) moving at (0.5, 0) m/s. Calculate the velocity obstacle region that would cause a collision within 2 seconds."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Path Optimization"}),": Given a path with waypoints [(0,0), (1,1), (2,1), (3,2)], find a shorter path by removing one intermediate waypoint while ensuring collision-free motion in a space with an obstacle at (1.5, 0.8) with radius 0.3."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"programming-exercises",children:"Programming Exercises"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Implement Dijkstra's Algorithm"}),": Create a function that finds the shortest path in a weighted graph representation of a grid map."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\n\ndef dijkstra(grid_map: np.ndarray, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    """\n    Find shortest path using Dijkstra\'s algorithm\n    Args:\n        grid_map: 2D array where 0=free, 1=obstacle\n        start: Starting coordinates (row, col)\n        goal: Goal coordinates (row, col)\n    Returns:\n        List of coordinates representing the shortest path\n    """\n    # Your implementation here\n    pass\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.em,{children:[(0,s.jsx)(e.em,{children:"RRT"})," Implementation"]}),"*: Enhance the basic RRT implementation to include rewiring for asymptotic optimality."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\n\nclass RRTStarPlanner:\n    def __init__(self, start: np.ndarray, goal: np.ndarray, bounds: List[Tuple[float, float]], \n                max_iterations: int = 10000, step_size: float = 0.1, \n                search_radius_factor: float = 1.1):\n        # Initialize like RRT but add parameters for rewiring\n        pass\n    \n    def plan(self) -> List[np.ndarray]:\n        """Plan path using RRT* algorithm with rewiring"""\n        # Your implementation here\n        pass\n    \n    def rewire_node(self, new_node):\n        """Rewire nodes to improve path cost"""\n        # Your implementation here\n        pass\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Path Smoothing"}),": Implement a path smoothing algorithm that takes a discrete path and returns a smooth trajectory."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\n\ndef smooth_path(path: List[Tuple[float, float]], \n                grid_map: np.ndarray, \n                max_iterations: int = 100,\n                weight_data: float = 0.5,\n                weight_smooth: float = 0.3) -> List[Tuple[float, float]]:\n    """\n    Smooth path using gradient descent\n    Args:\n        path: Original path as list of (x, y) coordinates\n        grid_map: Grid map for collision checking\n        max_iterations: Number of smoothing iterations\n        weight_data: Weight for original path fidelity\n        weight_smooth: Weight for smoothness\n    Returns:\n        Smoothed path\n    """\n    # Your implementation here\n    pass\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"design-problems",children:"Design Problems"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Navigation System Design"}),": Design a complete navigation system for a humanoid robot that includes:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Global path planner (how it handles updates to the map)"}),"\n",(0,s.jsx)(e.li,{children:"Local planner for obstacle avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Integration with footstep planning for bipedal motion"}),"\n",(0,s.jsx)(e.li,{children:"Recovery behaviors for when planning fails"}),"\n",(0,s.jsx)(e.li,{children:"Safety mechanisms to stop the robot when needed"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Multi-Modal Planning"}),": Design a navigation system that can switch between different locomotion modes (walking, crawling, climbing stairs) based on environmental conditions. Specify:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"How the system detects appropriate locomotion modes"}),"\n",(0,s.jsx)(e.li,{children:"How paths are planned for different modes"}),"\n",(0,s.jsx)(e.li,{children:"How transitions between modes are handled"}),"\n",(0,s.jsx)(e.li,{children:"How the system validates mode feasibility"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Human-Aware Navigation"}),": Design a navigation system that respects social conventions when moving through spaces with humans. Consider:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"How to model human social spaces"}),"\n",(0,s.jsx)(e.li,{children:"How to predict human movements"}),"\n",(0,s.jsx)(e.li,{children:"How to plan paths that are socially acceptable"}),"\n",(0,s.jsx)(e.li,{children:"How to handle interactions with humans"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"simulation-exercises",children:"Simulation Exercises"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Compare Path Planners"}),": Implement both A* and RRT on the same environment and compare their performance in terms of:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Computation time"}),"\n",(0,s.jsx)(e.li,{children:"Path quality (length, smoothness)"}),"\n",(0,s.jsx)(e.li,{children:"Success rate in different map types (open, cluttered, narrow passages)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Obstacle Navigation"}),": Create a simulation where a robot navigates towards a goal while avoiding moving obstacles using DWA. Analyze how different parameters affect navigation performance."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Footstep Planning Validation"}),": Implement a 2D footstep planner for a bipedal robot and simulate its navigation through various terrains with different obstacle configurations."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"analysis-problems",children:"Analysis Problems"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Computational Complexity"}),": Analyze the computational complexity of A* and RRT algorithms in terms of the number of grid cells or configuration space dimensions. When would you prefer each algorithm?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Path Optimality"}),": For a given environment with known optimal path length, compare the path quality produced by different algorithms (A*, RRT, RRT*) as computation time increases."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Real-time Performance"}),": Analyze the real-time performance of different planning algorithms, considering both average case and worst-case computation times."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"research-and-investigation",children:"Research and Investigation"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Literature Review"}),": Research recent advances in learning-based motion planning. Write a 500-word summary comparing traditional planning algorithms with learning-based approaches, including:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Technical differences"}),"\n",(0,s.jsx)(e.li,{children:"Advantages of each approach"}),"\n",(0,s.jsx)(e.li,{children:"Limitations and challenges"}),"\n",(0,s.jsx)(e.li,{children:"Applications where each approach is most suitable"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Case Study Analysis"}),": Analyze the navigation systems of three different humanoid robots (e.g., Boston Dynamics Atlas, Honda ASIMO, PAL Robotics TALOS). Create a comparative analysis focusing on:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Navigation algorithms used"}),"\n",(0,s.jsx)(e.li,{children:"Sensor configurations"}),"\n",(0,s.jsx)(e.li,{children:"Performance characteristics"}),"\n",(0,s.jsx)(e.li,{children:"Design trade-offs"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"practical-implementation-challenge",children:"Practical Implementation Challenge"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Build a Complete Navigation System"}),": Using a simulation environment (like PyBullet, Gazebo, or a custom 2D simulator):","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Implement a global path planner and local obstacle avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Add trajectory smoothing and velocity profiling"}),"\n",(0,s.jsx)(e.li,{children:"Include basic collision detection"}),"\n",(0,s.jsx)(e.li,{children:"Test on various map configurations"}),"\n",(0,s.jsx)(e.li,{children:"Document the system architecture and performance metrics"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"advanced-problems",children:"Advanced Problems"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Multi-Robot Navigation"}),": Design and implement a system for coordinating navigation of multiple humanoid robots in the same space, addressing:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"How to avoid collisions between robots"}),"\n",(0,s.jsx)(e.li,{children:"How to plan paths that account for other robots' movements"}),"\n",(0,s.jsx)(e.li,{children:"How to handle communication limitations"}),"\n",(0,s.jsx)(e.li,{children:"How to handle dynamic priority changes"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Learning from Demonstration"}),": Design a system that learns navigation behaviors from human demonstrations. Consider how to:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Record human navigation demonstrations"}),"\n",(0,s.jsx)(e.li,{children:"Extract relevant features from demonstrations"}),"\n",(0,s.jsx)(e.li,{children:"Generalize learned behaviors to new situations"}),"\n",(0,s.jsx)(e.li,{children:"Combine learned behaviors with traditional planning"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"discussion-questions",children:"Discussion Questions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Safety vs. Efficiency"}),": How do safety considerations affect path planning decisions? What trade-offs exist between safe, conservative planning and efficient navigation?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Uncertainty Handling"}),": How should navigation systems handle uncertainty in perception, map, and robot state? What planning approaches are most robust to uncertainty?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Learning vs. Planning"}),": When might learning-based navigation approaches be preferable to traditional algorithmic planning? Discuss the scenarios where each approach excels."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"solutions-and-hints",children:"Solutions and Hints"}),"\n",(0,s.jsx)(e.h3,{id:"problem-2-solution-outline",children:"Problem 2 Solution Outline:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Initialize open and closed sets"}),"\n",(0,s.jsx)(e.li,{children:"Start with cost 0 at (0,0)"}),"\n",(0,s.jsx)(e.li,{children:"For each node, compute cost to neighbors"}),"\n",(0,s.jsx)(e.li,{children:"Use priority queue to select next node"}),"\n",(0,s.jsx)(e.li,{children:"Stop when goal is reached"}),"\n",(0,s.jsx)(e.li,{children:"Reconstruct path from parent pointers"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"problem-5-solution-outline",children:"Problem 5 Solution Outline:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Try removing each intermediate waypoint"}),"\n",(0,s.jsx)(e.li,{children:"Check if the direct path between neighboring waypoints is collision-free"}),"\n",(0,s.jsx)(e.li,{children:"Compute the total path length for each valid simplification"}),"\n",(0,s.jsx)(e.li,{children:"Select the shortest valid path"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"programming-exercise-1-hints",children:"Programming Exercise 1 Hints:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use a priority queue to manage the open set"}),"\n",(0,s.jsx)(e.li,{children:"Track g-costs (distance from start) for each cell"}),"\n",(0,s.jsx)(e.li,{children:"Use parent pointers to reconstruct path"}),"\n",(0,s.jsx)(e.li,{children:"Only add valid neighbors to the open set"}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>r});var s=i(6540);const t={},a=s.createContext(t);function o(n){const e=s.useContext(a);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);