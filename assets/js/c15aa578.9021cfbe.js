"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[606],{5071:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>_,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var o=t(4848),r=t(8453);const l={},i="Chapter 3: Practical Applications of Motor Control and Actuation",s={id:"textbook/chapter3/practical",title:"Chapter 3: Practical Applications of Motor Control and Actuation",description:"Implementing PID Controllers for Motor Control",source:"@site/docs/textbook/chapter3/practical.md",sourceDirName:"textbook/chapter3",slug:"/textbook/chapter3/practical",permalink:"/Ai-book/docs/textbook/chapter3/practical",draft:!1,unlisted:!1,editUrl:"https://github.com/AftabAhmed4/Ai-book/edit/main/docs/textbook/chapter3/practical.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Chapter 3: Theoretical Foundations of Motor Control and Actuation",permalink:"/Ai-book/docs/textbook/chapter3/theory"},next:{title:"Chapter 3: Exercises and Problems",permalink:"/Ai-book/docs/textbook/chapter3/exercises"}},a={},p=[{value:"Implementing PID Controllers for Motor Control",id:"implementing-pid-controllers-for-motor-control",level:2},{value:"Basic PID Controller Implementation",id:"basic-pid-controller-implementation",level:3},{value:"Advanced Control: Inverse Kinematics Implementation",id:"advanced-control-inverse-kinematics-implementation",level:3},{value:"Implementing Balance Control",id:"implementing-balance-control",level:2},{value:"Center of Mass Control",id:"center-of-mass-control",level:3},{value:"Implementing Actuator Control",id:"implementing-actuator-control",level:2},{value:"Series Elastic Actuator (SEA) Control",id:"series-elastic-actuator-sea-control",level:3},{value:"Locomotion Control Implementation",id:"locomotion-control-implementation",level:2},{value:"Walking Pattern Generator",id:"walking-pattern-generator",level:3},{value:"Whole-Body Control Implementation",id:"whole-body-control-implementation",level:2},{value:"Task-Priority Control",id:"task-priority-control",level:3},{value:"Real-time Control Considerations",id:"real-time-control-considerations",level:2},{value:"Control Loop Implementation",id:"control-loop-implementation",level:3},{value:"Integration Example: Simple Walking Controller",id:"integration-example-simple-walking-controller",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"chapter-3-practical-applications-of-motor-control-and-actuation",children:"Chapter 3: Practical Applications of Motor Control and Actuation"}),"\n",(0,o.jsx)(n.h2,{id:"implementing-pid-controllers-for-motor-control",children:"Implementing PID Controllers for Motor Control"}),"\n",(0,o.jsx)(n.p,{children:"In this section, we'll explore practical implementations of PID controllers for motor control in humanoid robots."}),"\n",(0,o.jsx)(n.h3,{id:"basic-pid-controller-implementation",children:"Basic PID Controller Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport time\n\nclass PIDController:\n    def __init__(self, kp, ki, kd, output_limits=(-np.inf, np.inf)):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.output_limits = output_limits\n        \n        self.reset()\n    \n    def reset(self):\n        self.previous_error = 0.0\n        self.integral = 0.0\n        self.previous_time = time.time()\n    \n    def compute(self, setpoint, measured_value):\n        current_time = time.time()\n        dt = current_time - self.previous_time\n        \n        if dt <= 0.0:\n            return 0.0\n        \n        # Calculate error\n        error = setpoint - measured_value\n        \n        # Proportional term\n        p_term = self.kp * error\n        \n        # Integral term\n        self.integral += error * dt\n        i_term = self.ki * self.integral\n        \n        # Derivative term\n        derivative = (error - self.previous_error) / dt\n        d_term = self.kd * derivative\n        \n        # Calculate output\n        output = p_term + i_term + d_term\n        \n        # Apply output limits\n        output = np.clip(output, self.output_limits[0], self.output_limits[1])\n        \n        # Update state\n        self.previous_error = error\n        self.previous_time = current_time\n        \n        return output\n\n# Motor control example\nclass MotorController:\n    def __init__(self, kp=10.0, ki=0.1, kd=0.01):\n        self.position_controller = PIDController(kp, ki, kd)\n        self.velocity_controller = PIDController(2.0, 0.01, 0.1)\n        \n        # Motor parameters (example values for a servo motor)\n        self.motor_position = 0.0\n        self.motor_velocity = 0.0\n        self.target_position = 0.0\n        self.target_velocity = 0.0\n        self.max_torque = 10.0  # Nm\n    \n    def update(self, dt):\n        # Position control\n        position_error = self.target_position - self.motor_position\n        required_velocity = self.position_controller.compute(self.target_position, self.motor_position)\n        \n        # Velocity control\n        required_torque = self.velocity_controller.compute(required_velocity, self.motor_velocity)\n        \n        # Apply torque limits\n        required_torque = np.clip(required_torque, -self.max_torque, self.max_torque)\n        \n        # Update motor state (simplified model)\n        acceleration = required_torque  # Simplified: assuming unit inertia\n        self.motor_velocity += acceleration * dt\n        self.motor_position += self.motor_velocity * dt\n        \n        return {\n            'position': self.motor_position,\n            'velocity': self.motor_velocity,\n            'torque': required_torque\n        }\n"})}),"\n",(0,o.jsx)(n.h3,{id:"advanced-control-inverse-kinematics-implementation",children:"Advanced Control: Inverse Kinematics Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass InverseKinematics:\n    def __init__(self, links_lengths):\n        self.l = links_lengths  # List of link lengths\n    \n    def jacobian(self, joint_angles):\n        """Compute the geometric Jacobian for a planar manipulator"""\n        n = len(joint_angles)\n        jacobian = np.zeros((2, n))  # 2DOF position in 2D space\n        \n        # Calculate end-effector position for all joints\n        x = 0.0\n        y = 0.0\n        current_angle = 0.0\n        \n        # Position of end effector\n        for i in range(n):\n            current_angle += joint_angles[i]\n            x += self.l[i] * np.cos(current_angle)\n            y += self.l[i] * np.sin(current_angle)\n        \n        # Calculate Jacobian columns\n        current_angle = 0.0\n        x_cum = 0.0\n        y_cum = 0.0\n        \n        for i in range(n):\n            current_angle += joint_angles[i]\n            x_cum += self.l[i] * np.cos(current_angle)\n            y_cum += self.l[i] * np.sin(current_angle)\n            \n            # Column i of Jacobian\n            jacobian[0, i] = -y + y_cum  # \u2202x/\u2202\u03b8\u1d62\n            jacobian[1, i] = x - x_cum   # \u2202y/\u2202\u03b8\u1d62\n        \n        return jacobian\n    \n    def solve_ik(self, target_pos, current_angles, max_iter=100, threshold=1e-4):\n        """Solve inverse kinematics using Jacobian transpose method"""\n        angles = current_angles.copy()\n        \n        for i in range(max_iter):\n            # Calculate current end-effector position\n            current_pos = self.forward_kinematics(angles)\n            \n            # Calculate error\n            error = target_pos - current_pos\n            \n            if np.linalg.norm(error) < threshold:\n                break\n            \n            # Calculate Jacobian\n            J = self.jacobian(angles)\n            \n            # Update angles using Jacobian transpose\n            angles += 0.1 * J.T @ error  # Learning rate of 0.1\n        \n        return angles\n    \n    def forward_kinematics(self, joint_angles):\n        """Calculate end-effector position from joint angles"""\n        x = 0.0\n        y = 0.0\n        current_angle = 0.0\n        \n        for i, angle in enumerate(joint_angles):\n            current_angle += angle\n            x += self.l[i] * np.cos(current_angle)\n            y += self.l[i] * np.sin(current_angle)\n        \n        return np.array([x, y])\n\n# Example usage\nik_solver = InverseKinematics([0.5, 0.5, 0.3])  # 3-link arm\ntarget = np.array([0.7, 0.5])\ninitial_angles = np.array([0.1, 0.2, 0.05])\nsolution = ik_solver.solve_ik(target, initial_angles)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"implementing-balance-control",children:"Implementing Balance Control"}),"\n",(0,o.jsx)(n.h3,{id:"center-of-mass-control",children:"Center of Mass Control"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass BalanceController:\n    def __init__(self, robot_mass, gravity=9.81):\n        self.mass = robot_mass\n        self.gravity = gravity\n        \n        # ZMP controller parameters\n        self.zmp_kp = 100.0\n        self.zmp_kd = 20.0\n        \n        # Robot state\n        self.com_position = np.array([0.0, 0.0, 0.8])  # Center of mass (x, y, z)\n        self.com_velocity = np.array([0.0, 0.0, 0.0])\n        self.com_acceleration = np.array([0.0, 0.0, 0.0])\n        \n        self.support_polygon = np.array([[0.1, 0.1], [0.1, -0.1], [-0.1, -0.1], [-0.1, 0.1]])  # Example support polygon\n    \n    def calculate_zmp(self, com_pos, com_acc):\n        """Calculate Zero Moment Point from CoM position and acceleration"""\n        z_height = com_pos[2]\n        zmp_x = com_pos[0] - (z_height / self.gravity) * com_acc[0]\n        zmp_y = com_pos[1] - (z_height / self.gravity) * com_acc[1]\n        return np.array([zmp_x, zmp_y])\n    \n    def is_stable(self, zmp, tolerance=0.05):\n        """Check if ZMP is within support polygon with tolerance"""\n        zmp_x, zmp_y = zmp\n        \n        # Simplified check for rectangular support polygon\n        x_min = np.min(self.support_polygon[:, 0])\n        x_max = np.max(self.support_polygon[:, 0])\n        y_min = np.min(self.support_polygon[:, 1])\n        y_max = np.max(self.support_polygon[:, 1])\n        \n        return (x_min - tolerance <= zmp_x <= x_max + tolerance and\n                y_min - tolerance <= zmp_y <= y_max + tolerance)\n    \n    def balance_control(self, dt):\n        """Generate control commands to maintain balance"""\n        # Calculate current ZMP\n        current_zmp = self.calculate_zmp(self.com_position, self.com_acceleration)\n        \n        # Check if stable\n        if not self.is_stable(current_zmp):\n            # Generate corrective forces\n            zmp_error = -current_zmp  # Drive ZMP toward origin (center of support)\n            \n            # PID-like control for ZMP\n            corrective_force_x = self.zmp_kp * zmp_error[0] - self.zmp_kd * self.com_velocity[0]\n            corrective_force_y = self.zmp_kp * zmp_error[1] - self.zmp_kd * self.com_velocity[1]\n            \n            # Convert to CoM acceleration (assuming simplified model)\n            self.com_acceleration[0] = corrective_force_x / self.mass\n            self.com_acceleration[1] = corrective_force_y / self.mass\n        else:\n            # If stable, relax to desired CoM position\n            desired_com = np.array([0.0, 0.0, 0.8])\n            com_error = desired_com - self.com_position\n            self.com_acceleration = 2.0 * com_error - 2.0 * self.com_velocity  # PD controller\n        \n        # Update state\n        self.com_velocity += self.com_acceleration * dt\n        self.com_position += self.com_velocity * dt\n        \n        return {\n            \'com_position\': self.com_position.copy(),\n            \'com_velocity\': self.com_velocity.copy(),\n            \'zmp\': current_zmp,\n            \'stable\': self.is_stable(current_zmp)\n        }\n'})}),"\n",(0,o.jsx)(n.h2,{id:"implementing-actuator-control",children:"Implementing Actuator Control"}),"\n",(0,o.jsx)(n.h3,{id:"series-elastic-actuator-sea-control",children:"Series Elastic Actuator (SEA) Control"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class SeriesElasticActuator:\n    def __init__(self, motor_params, spring_constant=1000):\n        # Motor parameters\n        self.motor_inertia = motor_params['inertia']\n        self.gear_ratio = motor_params['gear_ratio']\n        self.motor_resistance = motor_params['resistance']\n        \n        # Spring parameters\n        self.k_spring = spring_constant\n        \n        # State variables\n        self.motor_position = 0.0\n        self.motor_velocity = 0.0\n        self.motor_acceleration = 0.0\n        self.spring_deflection = 0.0\n        self.load_position = 0.0\n        self.load_velocity = 0.0\n        \n        # Control parameters\n        self.position_controller = PIDController(50.0, 1.0, 0.1)\n        self.force_controller = PIDController(100.0, 5.0, 1.0)\n    \n    def update(self, target_position, target_force, dt):\n        \"\"\"Update SEA state based on control inputs\"\"\"\n        # Calculate spring force\n        spring_force = self.k_spring * self.spring_deflection\n        \n        # Calculate load acceleration (simplified model)\n        load_acceleration = (spring_force - target_force) / 1.0  # Assuming unit load inertia\n        \n        # Update load state\n        self.load_velocity += load_acceleration * dt\n        self.load_position += self.load_velocity * dt\n        \n        # Calculate motor control torque based on position error\n        motor_torque = self.position_controller.compute(target_position, self.load_position)\n        \n        # Apply motor dynamics (simplified)\n        self.motor_acceleration = (motor_torque - spring_force) / self.motor_inertia\n        self.motor_velocity += self.motor_acceleration * dt\n        self.motor_position += self.motor_velocity * dt\n        \n        # Update spring deflection\n        self.spring_deflection = self.motor_position - self.load_position\n        \n        return {\n            'load_position': self.load_position,\n            'load_velocity': self.load_velocity,\n            'spring_force': spring_force,\n            'deflection': self.spring_deflection\n        }\n\n# Example: Controlling a compliant manipulator\nsea_params = {\n    'inertia': 0.01,\n    'gear_ratio': 100,\n    'resistance': 0.5\n}\n\nsea = SeriesElasticActuator(sea_params, spring_constant=500)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"locomotion-control-implementation",children:"Locomotion Control Implementation"}),"\n",(0,o.jsx)(n.h3,{id:"walking-pattern-generator",children:"Walking Pattern Generator"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\n\nclass WalkingPatternGenerator:\n    def __init__(self, step_length=0.3, step_height=0.1, step_time=0.8):\n        self.step_length = step_length\n        self.step_height = step_height\n        self.step_time = step_time\n        self.dt = 0.01  # 100Hz control rate\n        \n        # Current state\n        self.phase = 0.0  # 0.0 to 1.0, representing phase in gait cycle\n        self.swing_leg = 'right'  # Which leg is currently swinging\n        self.left_foot_pos = np.array([0.0, 0.1, 0.0])\n        self.right_foot_pos = np.array([0.0, -0.1, 0.0])\n        self.com_height = 0.8  # Desired CoM height\n    \n    def generate_step_trajectory(self, start_pos, end_pos, height, t):\n        \"\"\"Generate smooth trajectory for foot movement during swing phase\"\"\"\n        # Use 5th order polynomial for smooth movement\n        # x(t) = a\u2080 + a\u2081t + a\u2082t\xb2 + a\u2083t\xb3 + a\u2084t\u2074 + a\u2085t\u2075\n        \n        # Boundary conditions:\n        # At t=0: x=0, \u1e8b=0, \u1e8d=0\n        # At t=1: x=1, \u1e8b=0, \u1e8d=0\n        t_norm = t  # Normalize time from 0 to 1\n        \n        # Calculate polynomial coefficients\n        a0 = 0.0\n        a1 = 0.0\n        a2 = 0.0\n        a3 = 10.0\n        a4 = -15.0\n        a5 = 6.0\n        \n        # Position along trajectory\n        x_progress = a0 + a1*t_norm + a2*t_norm**2 + a3*t_norm**3 + a4*t_norm**4 + a5*t_norm**5\n        \n        # Calculate foot position\n        current_pos = start_pos + x_progress * (end_pos - start_pos)\n        \n        # Calculate vertical position for step height\n        if t_norm < 0.5:\n            # Ascending phase\n            vertical_progress = (1 - np.cos(np.pi * t_norm)) / 2\n        else:\n            # Descending phase\n            vertical_progress = (1 - np.cos(np.pi * (1 - t_norm))) / 2\n        current_pos[2] = start_pos[2] + vertical_progress * height\n        \n        return current_pos\n    \n    def update(self, dt):\n        \"\"\"Update walking pattern based on time step\"\"\"\n        # Update gait phase\n        self.phase += dt / self.step_time\n        \n        if self.phase >= 1.0:\n            self.phase = 0.0\n            # Switch swing leg\n            if self.swing_leg == 'right':\n                self.swing_leg = 'left'\n                # Move right foot forward\n                self.left_foot_pos[0] += self.step_length\n            else:\n                self.swing_leg = 'right'\n                # Move left foot forward\n                self.right_foot_pos[0] += self.step_length\n        \n        # Calculate target foot positions\n        if self.swing_leg == 'right':\n            # Right foot is swinging forward\n            target_right_pos = self.generate_step_trajectory(\n                np.array([self.right_foot_pos[0] - self.step_length, self.right_foot_pos[1], 0.0]),\n                np.array([self.right_foot_pos[0] + self.step_length, self.right_foot_pos[1], 0.0]),\n                self.step_height,\n                self.phase\n            )\n            self.right_foot_pos = target_right_pos\n        else:\n            # Left foot is swinging forward\n            target_left_pos = self.generate_step_trajectory(\n                np.array([self.left_foot_pos[0] - self.step_length, self.left_foot_pos[1], 0.0]),\n                np.array([self.left_foot_pos[0] + self.step_length, self.left_foot_pos[1], 0.0]),\n                self.step_height,\n                self.phase\n            )\n            self.left_foot_pos = target_left_pos\n        \n        return {\n            'left_foot_pos': self.left_foot_pos.copy(),\n            'right_foot_pos': self.right_foot_pos.copy(),\n            'com_height': self.com_height,\n            'phase': self.phase,\n            'swing_leg': self.swing_leg\n        }\n\n# Example usage of walking controller\nwalker = WalkingPatternGenerator(step_length=0.3, step_height=0.05, step_time=1.0)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"whole-body-control-implementation",children:"Whole-Body Control Implementation"}),"\n",(0,o.jsx)(n.h3,{id:"task-priority-control",children:"Task-Priority Control"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy.linalg import block_diag\n\nclass WholeBodyController:\n    def __init__(self, num_joints, mass_matrix):\n        self.n = num_joints\n        self.M = mass_matrix  # Inertia matrix\n        self.gravity = 9.81\n        \n        # Initialize task Jacobians and desired values\n        self.tasks = []\n    \n    def add_task(self, task_type, jacobian, desired_value, priority=0, weight=1.0):\n        \"\"\"Add a control task to the system\"\"\"\n        task = {\n            'type': task_type,\n            'jacobian': jacobian,  # Size: (task_dim, n)\n            'desired': desired_value,  # Size: (task_dim,)\n            'priority': priority,\n            'weight': weight\n        }\n        self.tasks.append(task)\n        self.tasks.sort(key=lambda x: x['priority'], reverse=True)  # Higher priority first\n    \n    def compute_control(self, joint_angles, joint_velocities, gravity_compensation=True):\n        \"\"\"Compute joint torques using task-priority control\"\"\"\n        # Initialize nullspace projector\n        I = np.eye(self.n)\n        N_last = I.copy()\n        torques = np.zeros(self.n)\n        \n        # Process tasks in order of priority\n        for task in self.tasks:\n            J_task = task['jacobian']\n            x_des = task['desired']\n            \n            # Project Jacobian to current nullspace\n            J_proj = J_task @ N_last\n            \n            # Calculate task error\n            current_value = J_task @ joint_velocities  # Simplified for velocity control\n            error = x_des - current_value\n            \n            # Calculate control in the projected space\n            # Use damped least squares to avoid singularities\n            damping = 0.01\n            A = J_proj @ J_proj.T + damping * np.eye(J_proj.shape[0])\n            lambda_task = np.linalg.solve(A, error)\n            \n            # Calculate joint torques for this task\n            tau_task = N_last.T @ J_proj.T @ lambda_task\n            \n            # Add to total torques\n            torques += task['weight'] * tau_task\n            \n            # Update nullspace projector (for lower priority tasks)\n            # Calculate pseudo-inverse of projected Jacobian\n            J_pinv = J_proj.T @ np.linalg.inv(A)\n            \n            # Update nullspace projector\n            N_current = N_last @ (I - J_pinv @ J_proj)\n            N_last = N_current\n        \n        # Add gravity compensation if requested\n        if gravity_compensation:\n            g_compensation = self.compute_gravity_compensation(joint_angles)\n            torques += g_compensation\n        \n        return torques\n    \n    def compute_gravity_compensation(self, joint_angles):\n        \"\"\"Simple gravity compensation (in practice, this would be more complex)\"\"\"\n        # This is a simplified model - in practice, gravity terms depend on configuration\n        g_torques = np.zeros(self.n)\n        for i in range(self.n):\n            g_torques[i] = 0.5 * self.gravity * np.cos(joint_angles[i])\n        return g_torques\n\n# Example usage\nn_joints = 12  # Example for a simple humanoid\nM = np.eye(n_joints) * 0.5  # Simplified inertia matrix\n\nwbc = WholeBodyController(n_joints, M)\n\n# Add tasks (simplified examples)\n# Task 1: Left foot position control (high priority)\nJ_left_foot = np.random.rand(6, n_joints)  # 6DOF: 3 position + 3 orientation\nwbc.add_task('left_foot_pos', J_left_foot, np.zeros(6), priority=2, weight=1.0)\n\n# Task 2: Balance control (medium priority)\nJ_com = np.random.rand(2, n_joints)  # 2DOF: x,y position of CoM\nwbc.add_task('balance', J_com, np.zeros(2), priority=1, weight=0.5)\n\n# Task 3: Posture control (low priority)\nq_desired = np.zeros(n_joints)\nJ_posture = np.eye(n_joints)\nwbc.add_task('posture', J_posture, q_desired, priority=0, weight=0.1)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"real-time-control-considerations",children:"Real-time Control Considerations"}),"\n",(0,o.jsx)(n.h3,{id:"control-loop-implementation",children:"Control Loop Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import threading\nimport time\n\nclass RealtimeMotorController:\n    def __init__(self, control_frequency=1000):  # 1kHz control rate\n        self.control_freq = control_frequency\n        self.dt = 1.0 / control_freq\n        self.is_running = False\n        self.controller_thread = None\n        \n        # Initialize controllers\n        self.motors = {}  # Dictionary of motor controllers\n        self.robot_state = {}  # Current robot state\n        \n        # Performance monitoring\n        self.loop_times = []\n        self.target_time = 1.0 / control_frequency\n    \n    def add_motor(self, motor_id, controller_params):\n        \"\"\"Add a motor with its controller\"\"\"\n        self.motors[motor_id] = {\n            'controller': PIDController(**controller_params),\n            'current_pos': 0.0,\n            'current_vel': 0.0,\n            'target_pos': 0.0\n        }\n    \n    def set_target(self, motor_id, target_position):\n        \"\"\"Set target position for a specific motor\"\"\"\n        if motor_id in self.motors:\n            self.motors[motor_id]['target_pos'] = target_position\n    \n    def get_state(self, motor_id):\n        \"\"\"Get current state of a specific motor\"\"\"\n        if motor_id in self.motors:\n            return {\n                'position': self.motors[motor_id]['current_pos'],\n                'velocity': self.motors[motor_id]['current_vel']\n            }\n        return None\n    \n    def control_step(self):\n        \"\"\"Perform one control step\"\"\"\n        start_time = time.perf_counter()\n        \n        # Update each motor\n        for motor_id, motor_data in self.motors.items():\n            # Compute control output\n            output = motor_data['controller'].compute(\n                motor_data['target_pos'], \n                motor_data['current_pos']\n            )\n            \n            # Apply control (simulated motor dynamics)\n            motor_data['current_vel'] += output * self.dt  # Simplified\n            motor_data['current_pos'] += motor_data['current_vel'] * self.dt\n            \n            # In real hardware, send output to motor driver here\n        \n        # Record loop time for performance monitoring\n        end_time = time.perf_counter()\n        loop_time = end_time - start_time\n        self.loop_times.append(loop_time)\n        \n        # Maintain control frequency\n        sleep_time = self.target_time - loop_time\n        if sleep_time > 0:\n            time.sleep(sleep_time)\n        else:\n            # Control loop is too slow - log warning\n            print(f\"Control loop exceeded deadline by {abs(sleep_time)*1000:.2f}ms\")\n    \n    def start_control(self):\n        \"\"\"Start the real-time control loop\"\"\"\n        self.is_running = True\n        self.controller_thread = threading.Thread(target=self._control_loop)\n        self.controller_thread.start()\n    \n    def stop_control(self):\n        \"\"\"Stop the real-time control loop\"\"\"\n        self.is_running = False\n        if self.controller_thread:\n            self.controller_thread.join()\n        \n        # Print performance statistics\n        if self.loop_times:\n            avg_time = sum(self.loop_times) / len(self.loop_times)\n            max_time = max(self.loop_times)\n            print(f\"Control loop performance:\")\n            print(f\"  Average time: {avg_time*1000:.2f}ms\")\n            print(f\"  Max time: {max_time*1000:.2f}ms\")\n            print(f\"  Target time: {self.target_time*1000:.2f}ms\")\n    \n    def _control_loop(self):\n        \"\"\"Internal control loop function\"\"\"\n        while self.is_running:\n            self.control_step()\n\n# Example: Setting up a simple motor control system\nrt_controller = RealtimeMotorController(control_frequency=1000)\n\n# Add motors\nrt_controller.add_motor('hip', {'kp': 100.0, 'ki': 5.0, 'kd': 1.0})\nrt_controller.add_motor('knee', {'kp': 80.0, 'ki': 4.0, 'kd': 0.8})\nrt_controller.add_motor('ankle', {'kp': 60.0, 'ki': 3.0, 'kd': 0.6})\n\n# Set targets\nrt_controller.set_target('hip', 0.1)\nrt_controller.set_target('knee', -0.05)\nrt_controller.set_target('ankle', 0.02)\n\n# Start control (in a real scenario, this would run continuously)\n# rt_controller.start_control()\n# time.sleep(5)  # Run for 5 seconds\n# rt_controller.stop_control()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"integration-example-simple-walking-controller",children:"Integration Example: Simple Walking Controller"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class SimpleWalkingController:\n    def __init__(self):\n        # Initialize controllers for each leg\n        self.left_leg = MotorController(kp=50.0, ki=2.0, kd=5.0)\n        self.right_leg = MotorController(kp=50.0, ki=2.0, kd=5.0)\n        \n        # Walking state\n        self.phase = 0.0  # 0.0 to 1.0\n        self.step_time = 1.0  # 1 second per step\n        self.walk_active = False\n        \n    def step(self, dt):\n        """Perform one walking control step"""\n        if not self.walk_active:\n            return\n        \n        # Update phase\n        self.phase += dt / self.step_time\n        if self.phase > 1.0:\n            self.phase = 0.0\n        \n        # Generate walking pattern based on phase\n        self.generate_walking_pattern()\n        \n        # Update motor controllers\n        left_state = self.left_leg.update(dt)\n        right_state = self.right_leg.update(dt)\n        \n        return {\n            \'left_leg\': left_state,\n            \'right_leg\': right_state,\n            \'phase\': self.phase\n        }\n    \n    def generate_walking_pattern(self):\n        """Generate walking pattern based on current phase"""\n        # Simplified walking pattern\n        if self.phase < 0.5:\n            # Left leg swings forward, right leg supports\n            self.left_leg.target_position = 0.1 * np.sin(2 * np.pi * self.phase * 2)\n            self.right_leg.target_position = 0.0\n        else:\n            # Right leg swings forward, left leg supports\n            self.right_leg.target_position = 0.1 * np.sin(2 * np.pi * (self.phase - 0.5) * 2)\n            self.left_leg.target_position = 0.0\n    \n    def start_walking(self):\n        self.walk_active = True\n        self.phase = 0.0\n    \n    def stop_walking(self):\n        self.walk_active = False\n        self.left_leg.target_position = 0.0\n        self.right_leg.target_position = 0.0\n\n# Example usage\nwalker = SimpleWalkingController()\nwalker.start_walking()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"This chapter provided practical implementations of motor control and actuation systems for humanoid robots. We covered PID controllers, kinematic solutions, balance control, actuator control, and real-time implementation considerations. The examples can be adapted and extended for specific robot platforms and applications."}),"\n",(0,o.jsx)(n.p,{children:"These implementations form the foundation for developing sophisticated control systems that enable humanoid robots to move with stability and dexterity. In practice, these systems need to be tuned for specific hardware and applications, and often require significant optimization to run in real-time."})]})}function _(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var o=t(6540);const r={},l=o.createContext(r);function i(e){const n=o.useContext(l);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);