"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[160],{6859:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=i(4848),t=i(8453);const o={},r="Chapter 3: Exercises and Problems",l={id:"textbook/chapter3/exercises",title:"Chapter 3: Exercises and Problems",description:"Conceptual Questions",source:"@site/docs/textbook/chapter3/exercises.md",sourceDirName:"textbook/chapter3",slug:"/textbook/chapter3/exercises",permalink:"/Ai-book/docs/textbook/chapter3/exercises",draft:!1,unlisted:!1,editUrl:"https://github.com/AftabAhmed4/Ai-book/edit/main/docs/textbook/chapter3/exercises.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Chapter 3: Practical Applications of Motor Control and Actuation",permalink:"/Ai-book/docs/textbook/chapter3/practical"},next:{title:"Chapter 4: Motion Planning and Navigation",permalink:"/Ai-book/docs/textbook/chapter4/intro"}},a={},c=[{value:"Conceptual Questions",id:"conceptual-questions",level:2},{value:"Mathematical Problems",id:"mathematical-problems",level:2},{value:"Programming Exercises",id:"programming-exercises",level:2},{value:"Design Problems",id:"design-problems",level:2},{value:"Simulation Exercises",id:"simulation-exercises",level:2},{value:"Analysis Problems",id:"analysis-problems",level:2},{value:"Research and Investigation",id:"research-and-investigation",level:2},{value:"Practical Implementation Challenge",id:"practical-implementation-challenge",level:2},{value:"Discussion Questions",id:"discussion-questions",level:2},{value:"Solutions and Hints",id:"solutions-and-hints",level:2},{value:"Problem 1 Solution Outline:",id:"problem-1-solution-outline",level:3},{value:"Problem 3 Solution Outline:",id:"problem-3-solution-outline",level:3},{value:"Programming Exercise 1 Hints:",id:"programming-exercise-1-hints",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"chapter-3-exercises-and-problems",children:"Chapter 3: Exercises and Problems"}),"\n",(0,s.jsx)(n.h2,{id:"conceptual-questions",children:"Conceptual Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Compare and contrast"})," different actuation technologies (servo motors, series elastic actuators, hydraulic systems) in terms of power density, compliance, and control complexity. When would you choose each technology?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explain"})," the relationship between degrees of freedom and the complexity of inverse kinematics problems. What are the advantages and challenges of redundant manipulator systems?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Analyze"})," the role of the Zero Moment Point (ZMP) in bipedal walking stability. How does ZMP relate to the center of pressure?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Evaluate"})," the differences between impedance control and admittance control. Provide examples of when each approach would be most appropriate."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Discuss"})," the trade-offs between model-based control and learning-based control for motor control systems. What are the advantages of each approach?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mathematical-problems",children:"Mathematical Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Forward Kinematics"}),": For a 3-DOF planar manipulator with link lengths L\u2081 = 0.5m, L\u2082 = 0.4m, L\u2083 = 0.3m, calculate the end-effector position when joint angles are \u03b8\u2081 = \u03c0/4, \u03b8\u2082 = \u03c0/6, \u03b8\u2083 = \u03c0/3."]}),"\n",(0,s.jsx)(n.p,{children:"Use the forward kinematics equations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"x = L\u2081cos(\u03b8\u2081) + L\u2082cos(\u03b8\u2081+\u03b8\u2082) + L\u2083cos(\u03b8\u2081+\u03b8\u2082+\u03b8\u2083)\ny = L\u2081sin(\u03b8\u2081) + L\u2082sin(\u03b8\u2081+\u03b8\u2082) + L\u2083sin(\u03b8\u2081+\u03b8\u2082+\u03b8\u2083)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Inverse Kinematics"}),": For a 2-DOF planar manipulator with link lengths L\u2081 = 0.5m, L\u2082 = 0.4m, find the joint angles to reach the point (0.6, 0.4). Use the geometric solution approach."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ZMP Calculation"}),": A humanoid robot has a center of mass at (0.02, 0, 0.8) meters with acceleration (0.1, -0.05, 0) m/s\xb2. Calculate the ZMP position. Gravity is 9.81 m/s\xb2."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"PID Tuning"}),": Given a second-order system with transfer function G(s) = 1/(s\xb2 + 2s + 1), design a PID controller to achieve a settling time of less than 2 seconds with less than 5% overshoot. Use the Ziegler-Nichols method or pole placement."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Jacobian Calculation"}),": For a 2-DOF planar manipulator with link lengths L\u2081 and L\u2082, derive the Jacobian matrix J(\u03b8) relating joint velocities to end-effector velocities:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[\u1e8b]   [ \u2202x/\u2202\u03b8\u2081  \u2202x/\u2202\u03b8\u2082 ]\n[\u1e8f] = [ \u2202y/\u2202\u03b8\u2081  \u2202y/\u2202\u03b8\u2082 ] [\u03b8\u0307\u2081]\n                          [\u03b8\u0307\u2082]\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"programming-exercises",children:"Programming Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement a Joint Space Controller"}),": Create a controller that moves a robot arm from an initial joint configuration to a goal configuration using trajectory interpolation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\ndef joint_space_trajectory_planner(q_start, q_goal, t_total, dt=0.01):\n    """\n    Generate a smooth trajectory from start to goal joint angles\n    Args:\n        q_start: Initial joint angles (numpy array)\n        q_goal: Goal joint angles (numpy array)\n        t_total: Total movement time (seconds)\n        dt: Time step (seconds)\n    Returns:\n        List of (time, joint_angles) tuples\n    """\n    # Your implementation here (use cubic spline interpolation)\n    pass\n\ndef execute_trajectory(robot_model, trajectory_points):\n    """\n    Execute the trajectory on a robot model\n    Args:\n        robot_model: Robot model with forward kinematics\n        trajectory_points: List of (time, joint_angles) tuples\n    Returns:\n        List of end-effector positions over time\n    """\n    # Your implementation here\n    pass\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement a Simple Balance Controller"}),": Create a controller that keeps a simulated inverted pendulum upright using PID control."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass InvertedPendulum:\n    def __init__(self, length=1.0, mass=1.0, gravity=9.81):\n        self.length = length\n        self.mass = mass\n        self.gravity = gravity\n        self.angle = 0.1  # Initial angle (radians)\n        self.angular_velocity = 0.0\n    \n    def update(self, torque, dt):\n        """Update pendulum state with applied torque"""\n        # Calculate angular acceleration\n        angular_accel = (self.gravity / self.length) * np.sin(self.angle) + \\\n                       torque / (self.mass * self.length**2)\n        \n        # Update state\n        self.angular_velocity += angular_accel * dt\n        self.angle += self.angular_velocity * dt\n        \n        return self.angle, self.angular_velocity\n\ndef balance_controller(pendulum, kp=10, ki=1, kd=0.1):\n    """\n    Design a PID controller to balance the inverted pendulum\n    Args:\n        pendulum: InvertedPendulum instance\n        kp, ki, kd: PID gains\n    Returns:\n        Torque to apply based on current state\n    """\n    # Your implementation here\n    pass\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement Operational Space Control"}),": Create a controller that controls the end-effector position of a robot arm directly."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass OperationalSpaceController:\n    def __init__(self, robot_model):\n        self.robot = robot_model\n    \n    def inverse_kinematics(self, target_pos, current_joints):\n        """Solve inverse kinematics using Jacobian transpose"""\n        pass\n    \n    def operational_space_control(self, target_pos, current_pos, \n                                target_vel=np.zeros(2), current_vel=np.zeros(2)):\n        """\n        Control end-effector position in Cartesian space\n        Args:\n            target_pos: Desired end-effector position\n            current_pos: Current end-effector position\n            target_vel: Desired end-effector velocity\n            current_vel: Current end-effector velocity\n        Returns:\n            Joint torques to apply\n        """\n        pass\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"design-problems",children:"Design Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Design a Walking Controller"}),": Design a complete walking controller for a 6-DOF biped robot (3 DOF per leg). Your design should include:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Trajectory generator for foot placement"}),"\n",(0,s.jsx)(n.li,{children:"Balance control system"}),"\n",(0,s.jsx)(n.li,{children:"Joint controllers for each degree of freedom"}),"\n",(0,s.jsx)(n.li,{children:"Safety mechanisms to prevent falls"}),"\n",(0,s.jsx)(n.li,{children:"A state machine to manage different phases of walking"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Actuator Selection"}),": Design an actuation system for a humanoid robot arm with 7 DOF. Specify:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type of actuator for each joint (considering torque, speed, compliance requirements)"}),"\n",(0,s.jsx)(n.li,{children:"Control architecture for coordinated movement"}),"\n",(0,s.jsx)(n.li,{children:"Safety mechanisms to prevent damage during operation"}),"\n",(0,s.jsx)(n.li,{children:"Power consumption estimates for continuous operation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Robust Control Design"}),": Design a motor control system that remains stable under varying loads and parameter uncertainties. Consider:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adaptive control techniques"}),"\n",(0,s.jsx)(n.li,{children:"Gain scheduling approaches"}),"\n",(0,s.jsx)(n.li,{children:"Robustness analysis"}),"\n",(0,s.jsx)(n.li,{children:"Performance validation methods"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"simulation-exercises",children:"Simulation Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simulate a Manipulator Arm"}),": Create a simulation of a 3-DOF planar manipulator that can track a moving target. Implement both position and impedance control and compare their performance for different types of targets (stationary, moving, interactive)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Balance Control Simulation"}),": Simulate a 2D inverted pendulum model of a biped robot during standing and simple stepping motions. Implement ZMP-based balance control and test its performance under external disturbances."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Walking Pattern Validation"}),": Implement a 3D walking simulation with a simple humanoid model. Validate your walking pattern generator by testing stability across different walking speeds and step lengths."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"analysis-problems",children:"Analysis Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stability Analysis"}),": For a simple 2-DOF manipulator with given dynamics, analyze the stability of a PD control system. Determine conditions under which the system remains stable."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Energy Efficiency"}),": Compare the energy consumption of different control strategies (position control, impedance control, model-based control) for a repetitive manipulation task. Consider both theoretical analysis and simulation results."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Computational Complexity"}),": Analyze the computational requirements for inverse kinematics and dynamics calculations as the number of degrees of freedom increases. Propose optimization strategies for real-time implementation."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"research-and-investigation",children:"Research and Investigation"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Literature Review"}),": Research recent advances in artificial muscle technology for robotics. Write a 500-word summary comparing traditional actuators with artificial muscles, including:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Technical specifications and capabilities"}),"\n",(0,s.jsx)(n.li,{children:"Advantages for humanoid robotics applications"}),"\n",(0,s.jsx)(n.li,{children:"Current limitations and challenges"}),"\n",(0,s.jsx)(n.li,{children:"Future development prospects"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Case Study Analysis"}),": Analyze the motor control systems of three different humanoid robots (e.g., Boston Dynamics robots, Honda ASIMO, SoftBank Pepper). Create a comparative analysis focusing on:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Actuation technology used"}),"\n",(0,s.jsx)(n.li,{children:"Control strategies implemented"}),"\n",(0,s.jsx)(n.li,{children:"Performance characteristics"}),"\n",(0,s.jsx)(n.li,{children:"Design trade-offs made"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"practical-implementation-challenge",children:"Practical Implementation Challenge"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Build a Simple Robot Controller"}),": Using a simulation environment (like PyBullet, Gazebo, or MuJoCo) or physical hardware:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement a basic controller for a 2-3 DOF manipulator"}),"\n",(0,s.jsx)(n.li,{children:"Add a vision system for target detection"}),"\n",(0,s.jsx)(n.li,{children:"Implement visual servoing to reach a target"}),"\n",(0,s.jsx)(n.li,{children:"Document the control architecture and performance metrics"}),"\n",(0,s.jsx)(n.li,{children:"Identify and solve challenges faced during implementation"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"discussion-questions",children:"Discussion Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Safety Considerations"}),": How do safety considerations influence motor control design in humanoid robots? What control strategies can ensure safe human-robot interaction?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Learning vs. Model-Based Control"}),": When might learning-based motor control approaches be preferable to traditional model-based approaches? Discuss specific scenarios and applications."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Bio-inspiration"}),": How can insights from biological motor control systems inform the design of robotic control systems? What are the key differences between biological and artificial systems?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"solutions-and-hints",children:"Solutions and Hints"}),"\n",(0,s.jsx)(n.h3,{id:"problem-1-solution-outline",children:"Problem 1 Solution Outline:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use the forward kinematics equations with the given parameters"}),"\n",(0,s.jsx)(n.li,{children:"Calculate each link's contribution to the end-effector position"}),"\n",(0,s.jsx)(n.li,{children:"Add cos and sin components separately"}),"\n",(0,s.jsx)(n.li,{children:"The result should be in the form (x, y)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"problem-3-solution-outline",children:"Problem 3 Solution Outline:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use the ZMP formula: x_ZMP = x_COM - (h/g) * \u1e8d_COM"}),"\n",(0,s.jsx)(n.li,{children:"y_ZMP = y_COM - (h/g) * \xff_COM"}),"\n",(0,s.jsx)(n.li,{children:"Substitute the given values"}),"\n",(0,s.jsx)(n.li,{children:"The ZMP should be close to the CoM position if acceleration is small"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"programming-exercise-1-hints",children:"Programming Exercise 1 Hints:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Look up cubic spline interpolation formulas"}),"\n",(0,s.jsx)(n.li,{children:"For smooth trajectories, ensure continuity of position, velocity, and acceleration"}),"\n",(0,s.jsx)(n.li,{children:"Consider using the trapezoidal velocity profile for smoother motion"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);